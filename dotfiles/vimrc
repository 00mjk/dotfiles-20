set encoding=utf-8
scriptencoding utf-8

" --------------- "
" --- Plugins --- "
" --------------- "

call plug#begin('~/.vim/plugged')

" Plugins: General power-ups
" --------------------------

" Plug 'airblade/vim-current-search-match'

Plug 'AndrewRadev/splitjoin.vim'
Plug 'SirVer/ultisnips'
Plug 'ervandew/supertab'
Plug 'junegunn/vim-easy-align'
Plug 'terryma/vim-multiple-cursors'
Plug 'tpope/vim-abolish'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-sensible'
Plug 'tpope/vim-surround'
Plug 'dhruvasagar/vim-zoom'

" Plugins: Search (files and code)
" --------------------------------

Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
Plug 'junegunn/fzf.vim'
Plug 'mhinz/vim-grepper'

" Plugins: Navigate (files and code)
" ----------------------------------

Plug 'Xuyuanp/nerdtree-git-plugin'
Plug 'preservim/tagbar'
Plug 'preservim/nerdtree'

" Plugins: Language support (including special config syntaxes)
" -------------------------------------------------------------

Plug 'aklt/plantuml-syntax'
Plug 'ekalinin/Dockerfile.vim'
Plug 'elzr/vim-json'
Plug 'fatih/vim-go'
Plug 'fourjay/vim-yamsong'
Plug 'pangloss/vim-javascript'
Plug 'tmux-plugins/vim-tmux'
Plug 'vim-ruby/vim-ruby'
Plug 'rust-lang/rust.vim'
Plug 'ollykel/v-vim'
Plug 'tpope/vim-git'
Plug 'cespare/vim-toml'
Plug 'hashivim/vim-terraform'
Plug 'direnv/direnv.vim'

" Plugins: Markdown
" -----------------

" Tim Pope's Markdown plugin is included in Vim, but we want the latest
" version.
Plug 'tpope/vim-markdown'

" Tim Pope's Markdown plugin is the only one we know of that respects Vim
" formatting abilities (namely: correct recognition of paragraphs and lists),
" but its syntax highlight is often incorrect. vim-pandoc-syntax supports
" a superset of markdown.
Plug 'vim-pandoc/vim-pandoc-syntax'

" this way of installing markdown-preview assumes that node and yarn are available
Plug 'iamcco/markdown-preview.nvim', { 'do': 'cd app && yarn install'  }

" generate inline TOCs; for tagbar TOC support see TagBar config below
Plug 'mzlogin/vim-markdown-toc'

" tables
Plug 'dhruvasagar/vim-table-mode'

" Plugins: Language Server Protocol support
" -----------------------------------------

Plug 'dense-analysis/ale'
Plug 'ycm-core/YouCompleteMe'
" Plug 'jayli/vim-easycomplete'

" Plugins: Colorschemes
" ---------------------

Plug 'joshdick/onedark.vim'

call plug#end()

" ------------------------------- "
" --- Disable unused features --- "
" ------------------------------- "

" reverting the keys in :q (therefore bringing up the command history) is quite
" common and almost never what one wants, so it's disabled;
" however, since the command history is indeed useful sometimes, it's still
" possible to summon it with the Vim-native :<C-f>
map q: <Nop>
" remap Ex mode to 'formatting'
map Q gq
" disable compatibility with old vi
set nocompatible

" ------------------- "
" --- Colorscheme --- "
" ------------------- "

" Limiting themes to the 16 ANSI colours.
" Combined with suitable terminal palettes this makes it easier to use dark or
" light themes at the same time, for the purpose of pairing.
set t_Co=16

colorscheme peachpuff " part of the standard Vim distribution

" let g:onedark_termcolors=16
" colorscheme onedark

" ----------------------- "
" --- General options --- "
" ----------------------- "

" open a list of all the matches (list) *and* cycle through them (full)
" NOTE: disabled because currently (2022-02-14) incompatible with the popup option
" set wildmode=list:longest,full

set wildoptions+=pum

set wildignorecase
set wildignore+=*.swp,*/tmp/
set undolevels=5000

let s:swap_dir = $HOME . "/.vim/swp//"
let s:bkp_dir = $HOME . "/.vim/backup//"
let s:undo_dir = $HOME . "/.vim/undo//"

if !isdirectory(s:swap_dir) | call mkdir(s:swap_dir, "p", 0755) | endif
if !isdirectory(s:bkp_dir) | call mkdir(s:bkp_dir, "p", 0755) | endif
if !isdirectory(s:undo_dir) | call mkdir(s:undo_dir, "p", 0755) | endif

let &directory=s:swap_dir
let &undodir=s:undo_dir
let &backupdir=s:bkp_dir

set swapfile
set undofile
set backup

set lazyredraw

set autoread

" set timeoutlen=350 " (default 1000)
" time out on mapping after 1/2 second, time out on key codes after 1/10 of
" a second
set timeout timeoutlen=500 ttimeoutlen=100

set completeopt-=preview " do not open Preview split with docs for completion entries

" --- history --- "
set history=10000

" there is another setting that might override the history size, so we ensure to
" set that too; see "h 'viminfo'" (with quotes)
"
" default options:
"
" !   save and restore global variables that start with an uppercase letter
" '   max number of files to remember for marks
" h   disable effect of 'hlsearch' when loading viminfo file
" <   max number of lines saved per register
" s   max size of each register item in Kbytes
"
" additional option:
"
" :   max number of entries in the command history
set viminfo=!,'100,<50,s10,h,:1000

" --- jumping between pairs ---

set matchpairs+=<:>

" Write swap files to disk and trigger CursorHold event faster (default is
" after 4000 ms of inactivity)
set updatetime=200

" " Allow more time for loading syntax on large files
" set redrawtime=10000

set confirm

" ------------------------------- "
" --- Leader key alternatives --- "
" ------------------------------- "

" Preserves the native leader key.

nmap <space> \
vmap <space> \

" ---------------------- "
" --- Visual options --- "
" ---------------------- "

set number " show line numbers

" merge the sign column and the number column, to avoid shifting the content
set signcolumn=number

set cursorline
set showmatch " highlight matching parentheses
set matchtime=0 " ...but stay out of the way (do not jump around)

filetype plugin indent on " automatically detect file types.
syntax on

" show name of syntax element under the cursor (https://vi.stackexchange.com/a/19043)
command! SynName echo synIDattr(synID(line("."), col("."), 1), "name")

set noshowcmd                     " showcmd (on by default) is very noisy when running long commands, such as Ack
set noerrorbells visualbell t_vb= " disable all bells
set backspace=indent,eol,start    " allow extended backspace behaviour
set virtualedit=block             " allow placing the cursor after the last char in visual block
set scrolloff=3                   " number of lines and columns visible when scrolling
set sidescroll=3
set sidescrolloff=3
set splitright                    " position of the new split panes
set splitbelow
set shortmess-=S                  " show match count in searches

if exists('+colorcolumn')
  " https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=bdc48fa11e46f867ea4d75fa59ee87a7f48be144
  set colorcolumn=101 " display a vertical ruler for line length
  autocmd FileType qf,help,nerdtree,loclist set colorcolumn=
endif
" alternatively, https://github.com/seejohnrun/dotfiles
" au BufWinEnter * let w:m2=matchadd ( 'ErrorMsg' "18>80v. \+' -1)

" Compute syntax highlighting from beginning of file. (By default, vim only
" looks 200 lines back, which can make it highlight code incorrectly in some
" long files.)
autocmd BufEnter * :syntax sync fromstart

" ------------------------ "
" --- Custom filetypes --- "
" ------------------------ "

augroup ini_syntax
  autocmd! BufNewFile,BufFilePre,BufRead $HOME/.aws/* set filetype=dosini
augroup END

" --------------------------------------- "
" --- Syntax highlight customisations --- "
" --------------------------------------- "

if g:colors_name ==? "onedark" && filereadable(glob("~/.vimrc.highlights.onedark-16"))
  source ~/.vimrc.highlights.onedark-16
endif

if g:colors_name ==? "peachpuff" && filereadable(glob("~/.vimrc.highlights.peachpuff-16"))
  source ~/.vimrc.highlights.peachpuff-16
endif

" ---------------------- "
" --- Search options --- "
" ---------------------- "

set ignorecase  " ignore case when searching...
set smartcase   " ...unless one upper case letter is present in the word
set gdefault    " replace all the occurences in the line by default
set incsearch   " start searching without pressing enter
set hlsearch    " highlight results

" highlight current word without jumping to the next occurrence
map <Leader>h :let @/ = '\<'.expand('<cword>').'\>'\|set hlsearch<C-M>

" search and replace current word
nnoremap <Leader>r :%s/\<<C-r><C-w>\>/

" -------------------------------- "
" --- vim-current-search-match --- "
" -------------------------------- "

let g:current_search_match = 'BE_CurrentSearch'

" ----------------------------------- "
" --- Search for visual selection --- "
" ----------------------------------- "

" Search for selected text, forwards or backwards. It is case insensitive, and
" any whitespace is matched ('hello\nworld' matches 'hello world')
" makes * and # work on visual mode too.
"
" - http://vim.wikia.com/wiki/Search_for_visually_selected_text
" - http://vim.wikia.com/wiki/VimTip171
" - http://got-ravings.blogspot.com/2008/07/vim-pr0n-visual-search-mappings.html
" - https://github.com/nelstrom/vim-visual-star-search
" - http://vimcasts.org/episodes/search-for-the-selected-text/
function! s:VSetSearch(cmdtype)
  let temp = @s
  norm! gv"sy
  let @/ = '\V' . substitute(escape(@s, a:cmdtype.'\'), '\n', '\\n', 'g')
  let @s = temp
endfunction

xnoremap * :<C-u>call <SID>VSetSearch('/')<CR>/<C-R>=@/<CR><CR>
xnoremap # :<C-u>call <SID>VSetSearch('?')<CR>?<C-R>=@/<CR><CR>

" ------------------------------------------- "
" --- Search and replace visual selection --- "
" ------------------------------------------- "

" Start the find and replace command across the entire file
vnoremap <Leader>r <Esc>:%s/<c-r>=GetVimEscapedVisual()<cr>//c<Left><Left>
vnoremap <C-r> <Esc>:%s/<c-r>=GetVimEscapedVisual()<cr>//c<Left><Left>

" ------------------------------ "
" --- Visual selection utils --- "
" ------------------------------ "
"
" Based on
" * https://github.com/bryankennedy/vimrc/blob/master/vimrc
" * http://stackoverflow.com/questions/676600/vim-replace-selected-text/677918#677918
" * http://peterodding.com/code/vim/profile/autoload/xolox/escape.vim

function! GetVimEscapedVisual() range
  return VimEscape(GetVisual())
endfunction

" Escape special characters in a string for exact matching.
" This is useful to copying strings from the file to the search tool
function! VimEscape(string)
  let string=a:string
  " Escape regex characters
  let string = escape(string, '^$.*\/~[]')
  " Escape the line endings
  let string = substitute(string, '\n', '\\n', 'g')
  return string
endfunction

" Return the visually selected text without altering the unnamed register.
function! GetVisual() range
  " Save the current register and clipboard
  let reg_save = getreg('"')
  let regtype_save = getregtype('"')
  let cb_save = &clipboard
  set clipboard&

  " Put the current visual selection in the " register
  normal! ""gvy
  let selection = getreg('"')

  " Put the saved registers and clipboards back
  call setreg('"', reg_save, regtype_save)
  let &clipboard = cb_save

  return selection
endfunction

function! ShellEscape(str)
  let str=a:str
  return shellescape(fnameescape(str))
endfunction

function! GetShellEscapedVisual() range
  return ShellEscape(GetVisual())
endfunction

" --------------------------------- "
" --- Reselect last edited text --- "
" --------------------------------- "

" Leader-gv selects text that was just just changed or pasted , similar to how
" the native gv reselects the last visual selection.
" <http://vim.wikia.com/wiki/Selecting_your_pasted_text>
nnoremap <expr> <Leader>gv '`[' . strpart(getregtype(), 0, 1) . '`]'

" --------------------- "
" --- Mouse support --- "
" --------------------- "

" see also <http://usevim.com/2012/05/16/mouse/>

set mouse=a " enable mouse mode

if has("mouse_sgr")
  set ttymouse=sgr
else
  set ttymouse=xterm2
end

set ttyfast          " Send more characters for redraws (faster scrolling)
set mousehide        " Hide mouse pointer while typing
set mousemodel=popup

" ---------------------------- "
" --- Tabs and indentation --- "
" ---------------------------- "

" Use 2-space soft tabs by defaults
" (it's overridden for languages with different conventions).
set autoindent  	" remember indent level after going to the next line.
set expandtab 		" replace tabs with spaces
set tabstop=2
set shiftwidth=2
set softtabstop=2

autocmd FileType python
	\ setlocal tabstop=4
	\ | setlocal softtabstop=4
	\ | setlocal shiftwidth=4

" --------------------------- "
" --- Indenting shortcuts --- "
" --------------------------- "

" Indent/Unindent visually selected lines without losing the selection.
vnoremap > >gv
vnoremap < <gv
" Indent single lines with a single keystroke. The ability to specify a motion
" is lost, but this caters for the more common use case, indent until the
" desired level is obtained.
nnoremap > >>
nnoremap < <<

" -------------------------- "
" --- Formatting options --- "
" -------------------------- "

" Ensure some formatting options, some of which may already be enabled by
" default, depending on the version of Vim.
"
" For auto-formatting of text (not just comments) to work, textwidth must be
" explicitly set (it's 0 by default).
set textwidth=80

" some of these options require that 'autoindent' is set
set formatoptions+=1 " don't break a line after a one letter word, but before
set formatoptions+=c " auto-wrap comments
set formatoptions+=j " remove the comment characters when joining lines
set formatoptions+=l " keep long lines when editing, if they were already long
set formatoptions+=n " recognise numbered lists (using 'formatlistpat')
set formatoptions+=q " allow formatting of comments with 'gq'
set formatoptions+=r " auto-add current comment leader on new lines both in insert mode
set formatoptions+=t " wrap text automatically using 'textwidth'

set formatoptions-=o " do not add comment leader to new lines created with 'o' or 'O'
set formatoptions-=a " do not reformat the entire paragraph on every change because it messes with commented code

" Disabling auto formatting for the following file types because the wrapping
" also seems to be applied to code, at least in some case such as
" autocompletion.
autocmd FileType swift,erb,sh,python,go set formatoptions-=t

" Use only one space after punctuation:
" http://en.wikipedia.org/wiki/Sentence_spacing#Typography
set nojoinspaces

" I - When moving the cursor up or down just after inserting indent for
" 'autoindent', do not delete the indent. (cpo+=I)
set cpoptions+=I

" --------------- "
" --- Folding --- "
" --------------- "

" autocmd FileType python setlocal foldmethod=indent
set foldmethod=syntax
set foldnestmax=1
set nofoldenable

" ------------------------- "
" --- Buffer management --- "
" ------------------------- "

" Reuse buffers: if a buffer is already open in another window, jump to it
" instead of opening a new window.
set switchbuf=useopen

" Allow to open a different buffer in the same window of a modified buffer
set hidden

" position of the new split panes
set splitbelow
set splitright

" Close the current buffer without closing the window
" <http://stackoverflow.com/a/8585343/417375>
nnoremap <Leader>x :bp<bar>sp<bar>bn<bar>bd<CR>

"--- Close all hidden non-special buffers ---"
"
" http://stackoverflow.com/questions/1534835/how-do-i-close-all-buffers-that-arent-shown-in-a-window-in-vim
" modified to ensure that the buffers to close are normal (listed) buffers
"
" Other similar functions:
" http://stackoverflow.com/questions/8450919/how-can-i-delete-all-hidden-buffers>
" https://gist.github.com/skanev/1068214>
" http://vim.1045645.n5.nabble.com/close-all-unvisible-buffers-td4262697.html>
function! CloseHiddenBuffers()
  " figure out which buffers are visible in any tab
  let visible = {}
  for t in range(1, tabpagenr('$'))
    for b in tabpagebuflist(t)
      let visible[b] = 1
    endfor
  endfor
  " close any buffer that's loaded and not visible and not special
  for b in range(1, bufnr('$'))
    " add buflisted() to avoid closing special buffers
    if bufloaded(b) && !has_key(visible, b) && buflisted(b)
      exe 'bd ' . b
    endif
  endfor
endfun

nnoremap <Leader>ch :call CloseHiddenBuffers()<CR>

" ---------------- "
" --- Wrapping --- "
" ---------------- "

" Do not visually wrap lines by default...
set nowrap
" ...but enable it for files that often have long lines
autocmd FileType markdown setlocal wrap

set breakindent " Align visually wrapped lines with the original indentation.
set linebreak " Break between words when wrapping (don't break within words).

" toggle wrapping with leader-w
" nmap <silent> <Leader>w :set wrap!<CR>

" allow navigating 'visual lines' with j/k and up/down, instead of actual lines
nnoremap j gj
nnoremap k gk
nnoremap <Down> gj
nnoremap <Up> gk
nnoremap <Home> g<Home>
" nnoremap <End>  g<End>

xnoremap j gj
xnoremap k gk
xnoremap <Down> gj
xnoremap <Up> gk
xnoremap <Home> g<Home>
" xnoremap <End>  g<End>

" inoremap <Down> <C-o>gj
" inoremap <Up> <C-o>gk

" insert mode needs special settings because it can break autocomplete and
" popups
" <https://vim.fandom.com/wiki/Move_cursor_by_display_lines_when_wrapping>
" command Wrap call Wrap()
noremap <silent> <Leader>w :call Wrap()<CR>

function Wrap()
  if &wrap
    echo "Wrap OFF"
    setlocal nowrap
    " TODO: restore a saved value of virtualedit (for now it's hardcoded to the
    " same known global value)
    set virtualedit=block
    silent! iunmap <buffer> <Up>
    silent! iunmap <buffer> <Down>
    silent! iunmap <buffer> <Home>
    silent! iunmap <buffer> <End>
  else
    echo "Wrap ON"
    setlocal wrap linebreak nolist
    " TODO: save the previous state of virtualedit if any
    set virtualedit=
    setlocal display+=lastline
    inoremap <buffer> <silent> <Up>   <C-o>gk
    inoremap <buffer> <silent> <Down> <C-o>gj
    inoremap <buffer> <silent> <Home> <C-o>g<Home>
    inoremap <buffer> <silent> <End>  <C-o>g<End>
  endif
endfunction

" ------------------------------------------------------------------- "
" --- Support vim options in individual files with magic comments --- "
" ------------------------------------------------------------------- "

set modeline
set modelines=3

" --------------------------------------------------------- "
" --- Remember cursor position (when re-opening a file) --- "
" --------------------------------------------------------- "

" Exclude git commit messages.
let cursorRestoreExclusions = ['gitcommit']

autocmd BufReadPost *
  \ if index(cursorRestoreExclusions, &ft) < 0
	\ && line("'\"") > 1
  \ && line("'\"") <= line("$") |
  \   exe "normal! g`\"" |
  \ endif

" --------------------- "
" --- Misc mappings --- "
" --------------------- "

" write all changed buffers with Ctrl-S
inoremap <C-S> <ESC>:wall<CR>
nnoremap <C-S> :wall<CR>

" Map F1 key (main vim help) to ESC to avoid bringing it up by mistake.
nnoremap <F1> <ESC>
vnoremap <F1> <ESC>
inoremap <F1> <ESC>

" copy current file and line to the system clipboard
nnoremap <leader>y :let @+=expand("%:p") . ':' . line(".")<CR>

" typing '%%' in the command line will be expanded to the directory of the
" current file
cnoremap <expr> %% fnameescape(expand('%:h')).'/'

" Allow gf to open non-existent files
map gf :edit <cfile><cr>

" Easy insertion of a trailing ; or , from insert mode
" imap ;; <Esc>A;<Esc>
" imap ,, <Esc>A,<Esc>

" ---------------------- "
" --- Save with sudo --- "
" ---------------------- "

" http://www.commandlinefu.com/commands/view/1204/save-a-file-you-edited-in-vim-without-the-needed-permissions
if !exists(":Sudow")
  command Sudow :execute ':silent w !sudo tee % > /dev/null' | :edit!
endif

" ---------------------------------------- "
" --- Command aliases for common typos --- "
" ---------------------------------------- "

" http://vimdoc.sourceforge.net/htmldoc/usr_40.html#40.2
if !exists(":W")
  command W   w
endif
if !exists(":Wa")
  command Wa  wa
endif
if !exists(":WA")
  command WA  wa
endif
if !exists(":Q")
  command Q   q
endif
if !exists(":Qa")
  command Qa  qa
endif
if !exists(":QA")
  command QA  qa
endif
if !exists(":Wq")
  command Wq  wq
endif
if !exists(":Wqa")
  command Wqa wqa
endif
if !exists(":Xa")
  command Xa  xa
endif
if !exists(":Vs")
  command Vs  vs
endif
if !exists(":VS")
  command VS  vs
endif
if !exists(":Sp")
  command Sp  sp
endif
if !exists(":SP")
  command SP  sp
endif

" -------------------------- "
" --- Intuitive home key --- "
" -------------------------- "

" 1. Fix the home key inside tmux
if &term =~ '^screen'
  exec "set <Home>=\e[1~"
endif
" 2. remap the home key to toggle between first character and beginning of line
noremap <expr> <silent> <Home> col('.') == match(getline('.'),'\S')+1 ? '0' : '^'
" 3. also support insert mode
imap <silent> <Home> <C-O><Home>

" ---------------------------- "
" --- Quickfix and Loclist --- "
" ---------------------------- "

" force quickfix to always use the full width of the terminal at the bottom
" (and only the quickfix, not the location list, which instead belongs to each
" specific buffer)
" https://stackoverflow.com/a/59823132/417375
autocmd FileType qf if (getwininfo(win_getid())[0].loclist != 1) | wincmd J | endif

" Navigation
" ----------
" Useful for any type of search and command that populates the lists.
" TODO: isn't this already provided by the unimpaired plugin?

nmap [q :cprevious<CR>
nmap ]q :cnext<CR>

nmap [l :lprevious<CR>
nmap ]l :lnext<CR>

" Close quickfix list with Q like some plugins do
" -----------------------------------------------

" simply execute ':q<enter>' because both quickfix list and location list are
" of type qf, and if we use cclose in a location list it will try to close
" the quickfix if open in another window, not the current location list
autocmd FileType qf nnoremap <buffer> <silent> q :q<CR>

" Open quickfix results in vertical and horizontal splits
" -------------------------------------------------------
" with the same shortcuts provided by default by other plugins for the same
" purpose (<C-v> and <C-x>).

" Picking just the functionality we need from https://github.com/yssl/QFEnter

" This will only be called in the quickfix window, owing to the filetype
" restriction on the autocmd (see below).
function! <SID>OpenQuickfix(new_split_cmd)
  " 1. the current line is the result idx as we are in the quickfix
  let l:qf_idx = line('.')
  " 2. jump to the previous window
  wincmd p
  " 3. switch to a new split (the new_split_cmd will be 'vnew' or 'split')
  execute a:new_split_cmd
  " 4. open the 'current' item of the quickfix list in the newly created buffer
  "    (the current means, the one focused before switching to the new buffer)
  execute l:qf_idx . 'cc'
endfunction

autocmd FileType qf nnoremap <buffer> <C-v> :call <SID>OpenQuickfix("vnew")<CR>
autocmd FileType qf nnoremap <buffer> <C-x> :call <SID>OpenQuickfix("split")<CR>

" Automatically close the loclist when its corresponding buffer is closed
" -----------------------------------------------------------------------

augroup CloseLoclistWindowGroup
  autocmd!
  autocmd QuitPre * if empty(&buftype) | lclose | endif
augroup END

" Toggle location list
" --------------------

" very neat solution from https://vi.stackexchange.com/a/18090

function! BE_ToggleLocationList() abort
  " check if location list of current window is open
  if get(getloclist(0, {'winid':0}), 'winid', 0)
    lclose
  else
    lopen
  endif
endfunction

nmap <silent> <leader>l :call BE_ToggleLocationList()<CR>

" Toggle quickfix list
" --------------------

" TODO: use getqflist() instead

" https://stackoverflow.com/a/63162084/417375
function! BE_ToggleQuickfixList()
  if empty(filter(getwininfo(), 'v:val.quickfix'))
    copen
  else
    cclose
  endif
endfunction

nnoremap <silent> <leader>q :call BE_ToggleQuickfixList()<cr>

" ------------------------------ "
" --- Move lines up and down --- "
" ------------------------------ "

" Move lines up and down with Ctrl-arrowup/down and Ctrl-j/k (in normal, visual and insert mode)
" NOTE: only meant for small selections and small movements, will break moving
" multiple lines down beyond the bottom.
nnoremap <C-Down> :m .+1<CR>
nnoremap <C-Up> :m .-2<CR>
vnoremap <C-Down> :m '>+1<CR>gv
vnoremap <C-Up> :m '<-2<CR>gv
inoremap <C-Down> <ESC>:m .+1<CR>gi
inoremap <C-Up> <ESC>:m .-2<CR>gi
" For terminals where Ctrl-arrows are captured by the system.
nnoremap <C-j> :m .+1<CR>
nnoremap <C-k> :m .-2<CR>
vnoremap <C-j> :m '>+1<CR>gv
vnoremap <C-k> :m '<-2<CR>gv
inoremap <C-j> <ESC>:m .+1<CR>gi
inoremap <C-k> <ESC>:m .-2<CR>gi

" ------------------ "
" --- Whitespace --- "
" ------------------ "

" noremap <silent> <Leader>w :call Wrap()<CR>

" --- Visualise whitespace ---
" toggle hidden characters highlighting:

set listchars=tab:‚ñ∏¬∑,trail:¬∑,extends:>,precedes:<

nmap <silent> <Leader>ww :call ToggleVisualizeWhitespace()<CR>

function ToggleVisualizeWhitespace()
  if &list
    echo "Whitespace OFF"
    set nolist
  else
    echo "Whitespace ON"
    set list
  endif
endfunction

" --- Strip whitespace ---

" function! <SID>StripExtraWhitespace()
function! BE_StripExtraWhitespace()
  " store the original position
  let l = line(".")
  let c = col(".")
  %s/\s\+$//e " end of lines
  %s/\n\{3,}/\r\r/e " multiple blank lines
  silent! %s/\($\n\s*\)\+\%$// " end of file
  call cursor(l, c) " back to the original position
endfun

" autocmd FileType Dockerfile,make,c,coffee,cpp,css,eruby,eelixir,elixir,html,java,javascript,json,markdown,php,puppet,ruby,scss,sh,sql,text,tmux,typescript,vim,yaml,zsh,bash,dircolors,plantuml,cucumber autocmd BufWritePre <buffer> :call <SID>StripExtraWhitespace()
autocmd FileType Dockerfile,make,c,coffee,cpp,css,eruby,eelixir,elixir,html,java,javascript,json,markdown,php,puppet,ruby,scss,sh,sql,text,tmux,typescript,vim,yaml,zsh,bash,dircolors,plantuml,cucumber autocmd BufWritePre <buffer> :call BE_StripExtraWhitespace()

" StripTrailingWhitespace will not remove multiple blank lines, for langagues
" where that is the desired style.
" function! <SID>StripTrailingWhitespace()
function! BE_StripTrailingWhitespace()
  " store the original position
  let l = line(".")
  let c = col(".")
  %s/\s\+$//e " end of lines
  silent! %s/\($\n\s*\)\+\%$// " end of file
  call cursor(l, c) " back to the original position
endfun

autocmd FileType python autocmd BufWritePre <buffer> :call BE_StripTrailingWhitespace()

" also available for manual execution, for files where it's not enabled by default
command! WhitespaceAll      call BE_StripExtraWhitespace()
command! WhitespaceTrailing call BE_StripTrailingWhitespace()

" -------------------- "
" --- Omnicomplete --- "
" -------------------- "

" Enable syntax-based for natively supported languages, and using ctags when
" available. Plugins will overwrite this with more specific setups as
" appropriate (like vim-go).
set omnifunc=syntaxcomplete#Complete

" instruct supertab to try and detect the most appropriate autocompletion
" method, thus minimising the need for pressing the `<C-x><C-o>` combination
" let g:SuperTabDefaultCompletionType = "context"

" let g:SuperTabMappingForward  = '<s-tab>'
" let g:SuperTabMappingBackward = '<tab>'

" Allow the `enter' key to chose from the omnicompletion window, instead of <C-y>
" http://vim.wikia.com/wiki/Make_Vim_completion_popup_menu_work_just_like_in_an_IDE
" inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"

" --------------------------- "
" --- YouCompleteMe / YCM --- "
" --------------------------- "

" Tentative configuration
" -----------------------

" don't override <Leader-d>
let g:ycm_key_detailed_diagnostics = ''

let g:ycm_complete_in_comments = 1
let g:ycm_filepath_completion_use_working_dir = 1

let g:ycm_gopls_binary_path = 'gopls'
let g:ycm_gopls_args = ['-remote=auto']

let g:ycm_show_diagnostics_ui = 0
let g:ycm_update_diagnostics_in_insert_mode = 0
let g:ycm_auto_hover = ''

" disable tab, or it won't be possible to expand the Ultisnips snippet
" let g:ycm_key_list_select_completion = ['<Down>']
" let g:ycm_key_list_previous_completion = ['<Up>']

" " https://stackoverflow.com/a/22253548
" " make YCM compatible with UltiSnips (using supertab)
let g:ycm_key_list_select_completion = ['<C-n>', '<Down>']
let g:ycm_key_list_previous_completion = ['<C-p>', '<Up>']
" let g:SuperTabDefaultCompletionType = '<C-n>'
"
" " better key bindings for UltiSnipsExpandTrigger
" let g:UltiSnipsExpandTrigger = "<tab>"
" let g:UltiSnipsJumpForwardTrigger = "<tab>"
" let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"

" https://gist.github.com/lencioni/dff45cd3d1f0e5e23fe6
" let g:SuperTabDefaultCompletionType    = '<C-n>'

" the Enter behaviour in the popup menu is already handled in this vimrc
" let g:SuperTabCrMapping                = 0
let g:SuperTabCrMapping                = 1
" for some unholy reason after installing YCM, SuperTab works in reverse, so we
" need to swap the two mappings
let g:SuperTabMappingForward  = '<s-tab>'
let g:SuperTabMappingBackward = '<tab>'
" let g:UltiSnipsExpandTrigger           = '<tab>'
" let g:UltiSnipsJumpForwardTrigger      = '<tab>'
" let g:UltiSnipsJumpBackwardTrigger     = '<s-tab>'
let g:UltiSnipsExpandTrigger           = '<C-j>'
let g:UltiSnipsJumpForwardTrigger      = '<C-j>'
let g:UltiSnipsJumpBackwardTrigger     = '<C-k>'
" let g:ycm_key_list_select_completion   = ['<C-j>', '<C-n>', '<Down>']
" let g:ycm_key_list_previous_completion = ['<C-k>', '<C-p>', '<Up>']

let g:ycm_min_num_of_chars_for_completion = 99
" let g:ycm_auto_trigger = 0 " also disables argument hints (signature help)

" None of these seems to work
" ---------------------------
"
" so it doesn't seem to be possible to free up the <C-space> for tmux
"
" let g:ycm_key_invoke_completion = '<C-#>'
" let g:ycm_key_invoke_completion = '<C-x><C-x>'
" let g:ycm_key_invoke_completion = '<C-X><C-O>'
" let g:ycm_key_invoke_completion = '<Tab>'

" ---------------------- "
" --- Copy and Paste --- "
" ---------------------- "

set pastetoggle=<F3>

" --- Paste over visual selection preserving the content of the paste buffer
"
" p   -> paste normally
" gv  -> reselect the pasted text
" y   -> copy it again
" `>  -> jump to the last character of the visual selection (built-in mark)
vnoremap <Leader>p pgvy`>

" --- Make shift-Y consistent with shift-C and shift-D --- "
"
" shift-C changes till the end of line, and shift-D deletes till the of the line.
" shift-Y breaks the pattern, and it's an alias for `yy'.
" This was once in vim-sensible but then removed.
nnoremap Y y$

" --- Enter Insert mode directly in Paste mode
"
" 'borrowed' from
" <https://github.com/zonk1024/vim_stuffs/blob/281b4dfe92d4883550659989c71ec72350f3dd10/vimrc#L129>

" Turns on paste mode, puts you in insert mode then autocmds the cleanup
function! InsertPaste() range
  set paste
  startinsert
  augroup PasteHelper
    autocmd InsertLeave * call LeavePaste()
  augroup END
endfunction

" Same as above but on a new line
function! InsertPasteNewLine() range
  set paste
  call append(line("."), "")
  exec line(".")+1
	startinsert
  augroup PasteHelper
    autocmd InsertLeave * call LeavePaste()
  augroup END
endfunction

" Cleanup by turning off paste mode and unbinding itself from InsertLeave
function! LeavePaste() range
  set nopaste
  augroup PasteHelper
    autocmd!
  augroup END
endfunction

nnoremap <Leader>i :call InsertPaste()<CR>
nnoremap <Leader>o :call InsertPasteNewLine()<CR>

" " https://ddrscott.github.io/blog/2016/yank-without-jank/
" vnoremap <expr>y "my\"" . v:register . "y`y"

" ------------------- "
" --- Real delete --- "
" ------------------- "
"
" Delete without yanking, send the deleted content to the 'black hole' register.
" https://stackoverflow.com/questions/7501092/can-i-map-alt-key-in-vim
" http://vim.wikia.com/wiki/Get_Alt_key_to_work_in_terminal
" TODO: check and fix Alt-D on Linux via iTerm
" if has('linux')
"   set <M-d>=d
" elseif has('osxdarwin')
  set <M-d>=‚àÇ
" endif

" ...then, the actual mapping:
" current line in normal and insert mode
nnoremap <M-d> "_dd
nnoremap <Leader>d "_dd
" selection in visual mode
vnoremap <M-d> "_d
vnoremap <Leader>d "_d

" also prevent 'x' from overriding what's in the clipboard
noremap x "_x
noremap X "_x

" ---------------------- "
" --- Spell checking --- "
" ---------------------- "

" toggle spell checking with <F6>
nnoremap <F6> :setlocal spell!<CR>
vnoremap <F6> :setlocal spell!<CR>
inoremap <F6> <Esc>:setlocal spell!<CR>

" Recompile the personal spell file if newer than the compiled version.
" Useful when synchronising the spell file with Dropbox or git.
" https://vi.stackexchange.com/a/5052
for dict in glob('~/.vim/spell/*.add', 1, 1)
  if filereadable(dict) && (!filereadable(dict . '.spl') || getftime(dict) > getftime(dict . '.spl'))
    silent exec 'mkspell! ' . fnameescape(dict)
  endif
endfor

" Automatically enable spell checking for some filetypes.
" <http://robots.thoughtbot.com/vim-spell-checking>
" autocmd BufRead,BufNewFile *.md setlocal spell
" autocmd FileType markdown setlocal spell
autocmd FileType gitcommit setlocal spell

" ------------------------------------ "
" --- Pandoc Syntax (for Markdown) --- "
" ------------------------------------ "

augroup pandoc_syntax
    autocmd! BufNewFile,BufFilePre,BufRead *.md set filetype=markdown.pandoc
    autocmd! BufNewFile,BufFilePre,BufRead *.txt set filetype=markdown.pandoc
augroup END

let g:pandoc#syntax#conceal#use = 0
let g:pandoc#syntax#style#underline_special = 0
let g:pandoc#syntax#style#use_definition_lists = 0

let g:pandoc#syntax#codeblocks#embeds#langs = [
\  'go',
\  'ruby',
\  'sh',
\  'bash=sh',
\  'zsh',
\  'plantuml',
\  'python',
\  'json',
\  'yaml',
\  'vim',
\  'java',
\  'config',
\  'json',
\]

" ----------------------------- "
" --- markdown-preview.nvim --- "
" ----------------------------- "

let g:mkdp_auto_close = 0
let g:mkdp_refresh_slow = 1

let g:mkdp_filetypes = ['markdown', 'markdown.pandoc']

" Do not use the public PlantUML server.
" Instead, run it locally with
"
"    docker run --rm -d -p 56789:56789 plantuml/plantuml-server:jetty
"
" For more options, see <https://github.com/gmunguia/markdown-it-plantuml#advanced-usage>
" which is the underlying Node.js app that handles the connection to the
" PlantUML server.
let g:mkdp_preview_options = {
\  'uml': {'server': 'http://localhost:56789'},
\}

" ---------------------- "
" --- vim-table-mode --- "
" ---------------------- "

let g:table_mode_disable_mappings = 1 " this seems to have no effect
" let g:table_mode_insert_column_before_map = '<Leader>tib'

"-----------------------"
"--- Auto-formatting ---"
"-----------------------"

"--- Autoformat JSON with jq ---"

if executable('jq')
  " -M monochrome
  " -r raw output
  autocmd FileType json command! -nargs=0 Format execute ':%! jq -Mr .'
endif

"--- Autoformat XML with xmllint ---"

if executable('xmllint')
  autocmd FileType xml command! -nargs=0 Format execute ':%! xmllint --format --nowarning -'
endif

"--- Autoformat HTML with tidy ---"

if executable('tidy')
  autocmd FileType html command! -nargs=0 Format execute ':%! tidy -'
endif

" ---------------- "
" --- vim-ruby --- "
" ---------------- "

" Highlight ruby operators (`/`, `&&`, `*`...)
let g:ruby_operators = 1
let g:ruby_indent_assignment_style = 'variable'
let g:ruby_indent_block_style = 'do'

" ----------------- "
" --- vim-RSpec --- "
" ----------------- "

" --- Syntax highlighting outside Rails ---

autocmd BufRead {*_spec.rb,spec_helper.rb} syn keyword rubyRspec
      \ after
      \ before
      \ class_double
      \ contain_exactly
      \ context
      \ describe
      \ described_class
      \ double
      \ expect
      \ include_context
      \ include_examples
      \ instance_double
      \ it
      \ it_behaves_like
      \ it_should_behave_like
      \ its
      \ let
      \ object_double
      \ raise_error
      \ setup
      \ shared_context
      \ shared_examples
      \ shared_examples_for
      \ specify
      \ subject
      \ xit
      \ any_args
      \ anything
      \ array_including
      \ boolean
      \ duck_type
      \ hash_excluding
      \ hash_including
      \ instance_of
      \ kind_of
      \ no_args
      \ match_array

highlight def link rubyRspec Function

" ------------------------------------------------------- "
" --- File types for non-standard filename extensions --- "
" ------------------------------------------------------- "

autocmd BufNewFile,BufReadPost {*zsh,*.zsh-theme} set filetype=zsh
" autocmd BufNewFile,BufReadPost {.envrc,direnvrc,.direnvrc} set filetype=bash

" ---------------------------------------- "
" --- Fix arrow key combos inside tmux --- "
" ---------------------------------------- "

" this enables to use native and custom key combos inside tmux, as well as in
" standalone vim; relies on the term being correctly set inside tmux
"
"     set -g default-terminal 'tmux-256color'
"
if &term =~ '^tmux'
  exec "set <xUp>=\e[1;*A"
  exec "set <xDown>=\e[1;*B"
  exec "set <xRight>=\e[1;*C"
  exec "set <xLeft>=\e[1;*D"
endif

" ------------------------------------------------ "
" --- Navigate within and between vim and tmux --- "
" ------------------------------------------------ "

" Also see the corresponding tmux configuration in these dotfiles.

function! TmuxWinCmd(direction)
  let wnr = winnr()
  " try to move...
  silent! execute 'wincmd ' . a:direction
  " ...and if does nothing it means that it was the last vim pane,
  " so we forward the command back to tmux
  if wnr == winnr()
    call system('tmux select-pane -' . tr(a:direction, 'phjkl', 'lLDUR'))
  end
endfunction

nmap <silent> <M-Up>    :call TmuxWinCmd('k')<CR>
nmap <silent> <M-Down>  :call TmuxWinCmd('j')<CR>
nmap <silent> <M-Left>  :call TmuxWinCmd('h')<CR>
nmap <silent> <M-Right> :call TmuxWinCmd('l')<CR>

nmap <silent> <M-k>     :call TmuxWinCmd('k')<CR>
nmap <silent> <M-j>     :call TmuxWinCmd('j')<CR>
nmap <silent> <M-h>     :call TmuxWinCmd('h')<CR>
nmap <silent> <M-l>     :call TmuxWinCmd('l')<CR>

" ------------------- "
" --- vim-grepper --- "
" ------------------- "

" --- general options --- "

" the grepper variable will be merged with the defaults once the plugin loads
let g:grepper = {}

" list the possible search tools (backends) in order of preference, only the
" available executables will remain available once the plugin loads
let g:grepper.tools = [
  \'rg',
  \'ag',
  \'pt',
  \'ack',
  \'git',
  \'grep',
\]

let g:grepper.highlight = 1 " highlight matches
let g:grepper.stop = 1000 " stop searching after 1000 results, instead of the default 5000

" the following two settings will use the standard 10-line quickfix window
" no matter how many matches found; see ':h grepper-faq-4'
let g:grepper.open = 0
autocmd User Grepper copen

" focus the results automatically
let g:grepper.switch = 1

" --- prompt --- "
"
" the prompt is a nice to have, and provides different functionality than the
" command above, in particular shortcuts for changing search tool (with <Tab>)
" and target directory of the search (with <C-d>)
"
" however, it does not support path completion, and it causes a redraw when Esc
" is pressed

" this will open the Grepper prompt, where the search pattern can be entered
" (or by pressing Enter using the current word if no pattern is given)
nnoremap <Leader>g :Grepper<CR>

" only show a visual prompt, not the underlying search command;
let g:grepper.prompt_text = ' ‚ùØ‚ùØ '

" --- Ack-like custom command --- "
"
" build a command that that supports both current word (when no args are given),
" and path completion (like :Ack), because the Grepper prompt does not support
" completion
"
" what suggested in the vim-grepper docs is not a solution: setting
"
"     let g:grepper.prompt = 0
"
" will allow path completion after the search pattern, but it will not search
" for the current word with no input
"
function! AckgFunc(query)
  if a:query == ''
    execute 'Grepper -noprompt -cword'
  else
    execute 'Grepper -noprompt -query ' . a:query
  endif
endfunction

command! -nargs=* -complete=file Ackg call AckgFunc(<q-args>)

nnoremap <Leader>a :Ackg<Space>

" -- search current word --- "

nnoremap <Leader>8 :Grepper -open -cword -noprompt -switch<CR>
nnoremap <Leader>* :Grepper -open -cword -noprompt -switch<CR>

" --- operator --- "
"
" enable the operator in normal and visual mode, it will take a range or
" motion; see :help grepper-operator
nmap gs <plug>(GrepperOperator)
xmap gs <plug>(GrepperOperator)

" ---------------- "
" --- NERDTree --- "
" ---------------- "

" Shortcut to open/close
map <Leader>n :NERDTreeToggle<CR>
" Focus the current buffer in the tree
map <Leader>f :NERDTreeFind<CR>

let NERDTreeMinimalUI=1
let NERDTreeShowHidden=1
let NERDTreeNaturalSort=1
let NERDTreeIgnore = ['\.pyc$', '\.class$'] " http://superuser.com/questions/184844/hide-certain-files-in-nerdtree
let NERDTreeAutoDeleteBuffer=1 " automatically replace/close the corresponding buffer when a file is moved/deleted
let NERDTreeCascadeSingleChildDir=0 " do not collapse on the same line directories that have only one child directory
let NERDTreeStatusline="" " this seems to be ignored anyawy

" ----------------------------------- "
" --- fzf and fzf.vim integration --- "
" ----------------------------------- "

" See also https://github.com/junegunn/fzf/blob/master/README-VIM.md

" NOTE: Most of the options set with envars in the shell will also apply when
" fzf is invoked in Vim. Check those options in case of unwanted behaviour.

" run in a less intrusive terminal buffer at the bottom
let g:fzf_layout = { 'down': '~30%' }
" command to generate tags file
let g:fzf_tags_command = 'ctags -R'
" disable the preview window
let g:fzf_preview_window = []
" do not jump to the existing window if the buffer is already visible
" (sometimes we want to use the same buffer in a different window, for
" comparison or reference)
let g:fzf_buffers_jump = 0
" set fzf history specifically for use within Vim, separately from the global fzf history
let s:fzf_history_dir = $HOME . "/.vim/fzf-history//"
if !isdirectory(s:fzf_history_dir) | call mkdir(s:fzf_history_dir, "p", 0755) | endif
let g:fzf_history_dir = s:fzf_history_dir

" same keybindings used for CtrlP
nmap <C-p> :Files<CR>
nnoremap <Leader>b :Buffers<CR>
nnoremap <Leader>/ :BLines<CR>
" :History is similar to MRU buffers
nnoremap <Leader>m :History<CR>

" ---------------------- "
" --- vim-commentary --- "
" ---------------------- "

" Shortcuts
nmap <Leader>c gcc
vmap <Leader>c gc
" The underscore (_) represents the forward slash (/).
" See :help :map-special-keys.
" NOTE: this will not work with nnoremap and vnoremap
nmap <C-_> gcc
vmap <C-_> gc

autocmd FileType proto setlocal commentstring=//\ %s
autocmd FileType sql setlocal commentstring=--\ %s

" ---------------- "
" --- tcomment --- "
" ---------------- "

" nmap <Leader>c gcc
" nmap <C-_> gcc
" noremap <C-_> :TComment<CR>
" vnoremap <C-_> :TCommentMaybeInline<CR>
" inoremap <Plug>TComment_<c-_><c-_> <c-o>:TComment<cr>

" ------------- "
" --- v-vim --- "
" ------------- "

let g:v_autofmt_bufwritepre = 1

" -------------- "
" --- vim-go --- "
" -------------- "

" vim-go: completion, compatibility with YCM and Ultisnips
let g:go_code_completion_enabled = 0

" vim-go: gofmt
" -------------

" let g:go_fmt_autosave = 0
let g:go_fmt_fail_silently = 1
let g:go_gopls_gofumpt = v:true

" vim-go: goimports
" -----------------

" let g:go_imports_autosave = 0

" can be placed in a project-specific .vimrc, as exrc is enabled
" let g:go_gopls_local = "mymodule"

" let g:go_imports_mode = 'goimports'
" autocmd FileType go let b:go_fmt_options = {
"   \ 'goimports': '-local ' . trim(system('{cd '. shellescape(expand('%:h')) .' && go list -m;}')),
" \}

" vim-go: general options
" -----------------------

" let g:go_doc_balloon = 1
" let g:go_doc_popup_window = 1
" set ballooneval
" set balloonevalterm
" autocmd FileType go set balloonexpr=go#tool#DescribeBalloon()

" let g:go_code_completion_enabled = 0

let g:go_fillstruct_mode = 'gopls'
let g:go_list_type = 'quickfix'
let g:go_addtags_skip_unexported = 1 " do not add JSON tags to unexported fields when using :GoAddTags

" Show information about the identifier under the cursor (functions, vars..)...
"
" Needs to be disabled so tha ALE/linting/compile errors can be shown on hover
" without the need for opening the loclist.
" let g:go_auto_type_info = 1
" ...after 1000 ms instead of the default 800
" let g:go_updatetime=1000

let g:go_addtags_skip_unexported = 1

let g:go_test_show_name = 1

" works well only if both pairs are using a dedicated base16 colorscheme
" let g:go_auto_sameids = 1

" vim-go: mappings
" ----------------

" use A.L.E. for go to definition and similar actions
" let g:go_def_mapping_enabled = 0

autocmd FileType go nmap <buffer> <Leader>z <Plug>(go-diagnostic)
autocmd FileType go nmap <buffer> <Leader>t <Plug>(go-test)
autocmd FileType go nmap <buffer> <Leader>tf <Plug>(go-test-func)
autocmd FileType go nmap <buffer> <Leader>e <Plug>(go-decls)
autocmd FileType go nmap <buffer> <Leader>ee <Plug>(go-decls-dir)
autocmd FileType go nmap <buffer> <Leader>s :GoSameIdsToggle<CR>
" Since Shift+K in vim-go opens the docs for the current element, we use
" a similar mapping to display the info in the output of the commandline.
autocmd FileType go nmap <Leader>k <Plug>(go-info)
" to complement gd (go-def) which is provided by vim-go by default
autocmd FileType go nmap <buffer> gt <Plug>(go-def-type)
autocmd FileType go nmap <buffer> gr <Plug>(go-callers)
autocmd FileType go nmap <buffer> ge <Plug>(go-referrers)
autocmd FileType go nmap <buffer> gl <Plug>(go-implements)
autocmd FileType go nmap <buffer> gn <Plug>(go-rename)

" vim-go: debugging
" -----------------
" TODO: these mappings are useless, use some mnemonics.

let g:go_debug_windows = {
  \ 'vars':       'leftabove 30vnew',
  \ 'stack':      'leftabove 20new',
  \ 'goroutines': 'botright 10new',
\ }
" \ 'out':        'botright 5new', " remove the output window

" default mappings when debugger is active:
"
"   go-debug-continue   <F5>
"   go-debug-print      <F6>
"   go-debug-breakpoint <F9>
"   go-debug-next       <F10>
"   go-debug-step       <F11>
"   go-debug-halt       <F8>
"
" additional ones will be merged into the defaults
let g:go_debug_mappings = {
   \ '(go-debug-stop)':     {'key': '<F7>'},
   \ '(go-debug-stepout)':  {'key': '<F12>'},
\ }

autocmd FileType go nmap <buffer> <F2> <Plug>(go-debug-test-func)
autocmd FileType go nmap <buffer> <F4> <Plug>(go-debug-start)
autocmd FileType go nmap <buffer> <F9> <Plug>(go-debug-breakpoint)

" vim-go: syntax highlighting
" ---------------------------

highlight link goBuiltins Keyword

let g:go_highlight_extra_types = 1
let g:go_highlight_fields = 1
let g:go_highlight_format_strings = 1
let g:go_highlight_function_calls = 1
let g:go_highlight_function_parameters = 1
let g:go_highlight_functions = 1 " includes methods
let g:go_highlight_operators = 1
let g:go_highlight_string_spellcheck = 1 " even if it's currently the default
let g:go_highlight_types = 1

let g:go_highlight_generate_tags = 1
let g:go_highlight_build_constraints = 1
let g:go_highlight_variable_assignments = 1
let g:go_highlight_variable_declarations = 1

let g:go_highlight_debug = 0
let g:go_debug_breakpoint_sign_text = '‚ñ∂Ô∏é'

" ------------ "
" --- Rust --- "
" ------------ "

let g:rustfmt_autosave = 1
let g:rustfmt_autosave_if_config_present = 1
let g:rustfmt_options = '--edition 2021'

" ---------------------------------------------- "
" --- ALE (A.L.E., Asynchronous Lint Engine) --- "
" ---------------------------------------------- "

" let g:ale_completion_enabled = 1

" ALE: Language settings
" ----------------------

" set to 1 to disable all linters unless explicitly enabled, default 0
" let g:ale_linters_explicit = 1

" let g:ale_lint_on_save = 1

let g:ale_linters = {}
let g:ale_linters['rust'] = ['analyzer']
let g:ale_linters['javascript'] = ['eslint']
let g:ale_linters['html'] = []

let g:ale_fix_on_save = 1
let g:ale_fixers = {} " see also language specific settings
let g:ale_fixers['rust'] = ['rustfmt']

" ALE: Golang-specific settings
" -----------------------------

let g:ale_linters['go'] = ['gopls', 'govet', 'errcheck', 'staticcheck']
" let g:ale_fixers['go'] = ['gofumpt', 'goimports']

let g:ale_go_golangci_lint_options = '' " only use defaults
let g:ale_go_staticcheck_lint_package = 1

" undocumented: https://github.com/dense-analysis/ale/discussions/3977
" can be placed in a project-specific .vimrc, as exrc is enabled
" let g:ale_go_goimports_options = "-local=mymodule"

" struct literals without fields are useful, especially for special-purpose
" types with a single field (such as custom error types)
let g:ale_go_govet_options = '-composites=false'

let g:ale_go_langserver_executable = ''

" ensure only one gopls server is started, if working on multiple projects
let g:ale_go_gopls_options = '-remote=auto'

" enable non-default checks, and disable composites
let g:ale_go_gopls_init_options = {
\  'ui.diagnostic.analyses': {
\    'composites': v:false,
\    'unusedresult': v:true,
\    'unusedwrite': v:true,
\    'nilness': v:true,
\    'unusedparams': v:true,
\  },
\}

" autocmd FileType go nmap <buffer> <silent> <C-]> <Plug>(ale_go_to_definition)
" autocmd FileType go nmap <buffer> <silent> gd <Plug>(ale_go_to_definition)
" autocmd FileType go nmap <buffer> <silent> <C-t> <Plug>(ale_go_to_type_definition)

if executable('golines')
  autocmd FileType go command! GoLines ALEFix golines
endif

" run 'golines --help' for more options
let g:ale_go_golines_options = '--max-len=120'

" ALE: Python
" -----------

let g:ale_linters['python'] = ['flake8', 'pylint', 'mypy']
let g:ale_fixers['python'] = ['yapf']
autocmd FileType python set omnifunc=ale#completion#OmniFunc
autocmd FileType python nmap <buffer> <silent> <C-]> <Plug>(ale_go_to_definition)
autocmd FileType python nmap <buffer> <silent> gd <Plug>(ale_go_to_definition)
autocmd FileType python nmap <buffer> <silent> <C-t> <Plug>(ale_go_to_type_definition)

" ALE: Error list
" ---------------

" open the loclist automatically on errors; it will close anyway once all the
" issue have been addressed

" let g:ale_open_list = 1

" ALE: Visual customisations
" --------------------------

let g:ale_lint_on_text_changed = 'normal'
let g:ale_lint_on_insert_leave = 1
let g:ale_lint_on_enter = 1

let g:ale_sign_error = ' ‚ñ∂Ô∏é'
let g:ale_sign_warning = ' ‚ñ∂Ô∏é'
let g:ale_sign_info = ' ‚ñ∂Ô∏é'

" ALE: shortcuts and mappings
" ---------------------------

" Jump to next error or warning. Mnemomic: 'd' is for 'diagnostic'.
nmap <silent> ]d <Plug>(ale_next_wrap)
nmap <silent> [d <Plug>(ale_previous_wrap)

" ---------------- "
" --- vim-json --- "
" ---------------- "

let g:vim_json_syntax_conceal = 0

" -------------- "
" --- TagBar --- "
" -------------- "

" We cannot use <C-t>, as it's taken by vim-go.
nnoremap <silent> gb :TagbarToggle<CR>

" let g:tagbar_sort = 0 " list tags in order of appearance in the file

let g:tagbar_iconchars = ['‚ñ∂', '‚ó¢']

" https://github.com/preservim/tagbar/wiki#markdown
let g:tagbar_type_markdown = {
  \ 'ctagstype'  : 'markdown',
  \ 'kinds'    : [
    \ 'c:chapter:0:1',
    \ 's:section:0:1',
    \ 'S:subsection:0:1',
    \ 't:subsubsection:0:1',
    \ 'T:l4subsection:0:1',
    \ 'u:l5subsection:0:1',
  \ ],
  \ 'sro'      : '""',
  \ 'kind2scope'  : {
    \ 'c' : 'chapter',
    \ 's' : 'section',
    \ 'S' : 'subsection',
    \ 't' : 'subsubsection',
    \ 'T' : 'l4subsection',
  \ },
  \ 'scope2kind'  : {
    \ 'chapter' : 'c',
    \ 'section' : 's',
    \ 'subsection' : 'S',
    \ 'subsubsection' : 't',
    \ 'l4subsection' : 'T',
  \ },
\ }

" ------------- "
" --- Vista --- "
" ------------- "

let g:vista#renderer#enable_icon = 0

" ------------------ "
" --- Statusline --- "
" ------------------ "

let g:be_modes = {
  \ 'c'      : { 'name': 'COMMAND',     'highlight': 'BE_StatuslineCyan'    },
  \ 'n'      : { 'name': 'NORMAL',      'highlight': 'BE_StatuslineGreen'   },
  \ 'no'     : { 'name': 'N-PENDING)',  'highlight': 'BE_StatuslineGreen'   },
  \ 'i'      : { 'name': 'INSERT',      'highlight': 'BE_StatuslineMagenta' },
  \ 'R'      : { 'name': 'REPLACE',     'highlight': 'BE_StatuslineMagenta' },
  \ 'v'      : { 'name': 'VISUAL',      'highlight': 'BE_StatuslineBlue'    },
  \ 'V'      : { 'name': 'V-LINE',      'highlight': 'BE_StatuslineBlue'    },
  \ "\<C-v>" : { 'name': 'V-BLOCK',     'highlight': 'BE_StatuslineBlue'    },
  \ 'Rv'     : { 'name': 'V-REPLACE',   'highlight': 'BE_StatuslineMagenta' },
  \ 's'      : { 'name': 'SELECT',      'highlight': 'BE_StatuslineCyan'    },
  \ 'S'      : { 'name': 'S-LINE',      'highlight': 'BE_StatuslineCyan'    },
  \ "\<C-s>" : { 'name': 'S-BLOCK',     'highlight': 'BE_StatuslineCyan'    },
  \ 'cv'     : { 'name': 'VIM-EX',      'highlight': 'BE_StatuslineCyan'    },
  \ 'ce'     : { 'name': 'EX',          'highlight': 'BE_StatuslineCyan'    },
  \ 'r'      : { 'name': 'PROMPT',      'highlight': 'BE_StatuslineCyan'    },
  \ 'rm'     : { 'name': 'MORE',        'highlight': 'BE_StatuslineCyan'    },
  \ 'r?'     : { 'name': 'CONFIRM',     'highlight': 'BE_StatuslineCyan'    },
  \ '!'      : { 'name': 'SHELL',       'highlight': 'BE_StatuslineCyan'    },
  \ 't'      : { 'name': 'TERMINAL',    'highlight': 'BE_StatuslineCyan'    },
\}

let g:be_buffer_types = {
  \ 'quickfix' : { 'name': 'QUICKFIX',  'highlight': 'BE_StatuslineGrey' },
  \ 'loclist'  : { 'name': 'LOCLIST',   'highlight': 'BE_StatuslineRed'  },
  \ 'preview'  : { 'name': 'PREVIEW',   'highlight': 'BE_StatuslineCyan' },
  \ 'scratch'  : { 'name': 'SCRATCH',   'highlight': 'BE_StatuslineCyan' },
  \ 'help'     : { 'name': 'HELP',      'highlight': 'BE_StatuslineCyan' },
\}

" let g:BE_statusline_centre = ' %<%f %m%r%h%w %='
let g:BE_statusline_right = ' %4l:%-3c %6([%L]%)'
" let g:BE_statusline_right_only_lines = ' %4l %6([%L]%)'

function! BE_Statusline(active)
  " an empty buftype name means a normal buffer...
  if &l:buftype !=? '' && &l:buftype !=? 'quickfix' | return | endif
  " unless it's the Explore window netrw
  if &l:filetype ==? 'netrw' | return | endif
  " help is handled separately
  if &l:filetype ==? 'help' | return | endif

  " quickfix and loclist need to be handled both by filetype (for the
  " scenarios) where the Enter events don't trigger) and by event, because if
  " only the filetype is handled, both types of lists will be set with the same
  " type of statusline
  if &l:filetype ==? 'qf' && getwininfo(win_getid())[0].loclist == 1
    setlocal statusline=%!BE_ListsStatusline('loclist')
  elseif &l:filetype ==? 'qf'
    setlocal statusline=%!BE_ListsStatusline('quickfix')
  elseif &l:previewwindow == 1
    setlocal statusline=%!BE_ModeOnlyStatusline('preview')
  elseif (&l:buftype ==? 'nofile' && &l:filetype ==? '') || &l:buftype ==? 'acwrite'
    " it's a 'scratch' file (we neeed to check filetype is empty because
    " NERDTree is a 'nofile' too)
    setlocal statusline=%!BE_ModeOnlyStatusline('scratch')
  elseif a:active == 1
    setlocal statusline=%!BE_ActiveStatusline()
  else
    setlocal statusline=%!BE_InactiveStatusline()
  endif
endfunction

function! BE_ModeOnlyStatusline(buffer_type)
  let l:mode_name   = g:be_buffer_types[a:buffer_type]['name']
  let l:mode_colour = g:be_buffer_types[a:buffer_type]['highlight']

  let l:stl  = '%#'.l:mode_colour.'#'
  let l:stl .= ' '.l:mode_name.' '
  let l:stl .= '%#'.l:mode_colour.'Centre#'
  let l:stl .= ' '

  return l:stl
endfunction

function! BE_HelpStatusline()
  let l:mode_name   = g:be_buffer_types['help']['name']
  let l:mode_colour = g:be_buffer_types['help']['highlight']

  let l:stl  = '%#'.l:mode_colour.'#'
  let l:stl .= ' '.l:mode_name.' '
  let l:stl .= '%#'.l:mode_colour.'Centre#'
  let l:stl .= ' %F'

  return l:stl
endfunction

function! BE_ListsStatusline(list_type)
  let l:mode_name   = g:be_buffer_types[a:list_type]['name']
  let l:mode_colour = g:be_buffer_types[a:list_type]['highlight']

  let l:stl  = '%#'.l:mode_colour.'#'
  let l:stl .= ' '.l:mode_name.' '
  let l:stl .= '%#'.l:mode_colour.'Centre#'
  let l:stl .= ' [%L]'

  return l:stl
endfunction

function! BE_ListsStatuslineInitial()
  if getwininfo(win_getid())[0].loclist == 1
    let &l:statusline = BE_ListsStatusline('loclist')
  else
    let &l:statusline = BE_ListsStatusline('quickfix')
  endif
endfunction

" Integrate ALE results into the statusline, crude solution.
function! BE_LinterStatus() abort
    let l:counts = ale#statusline#Count(bufnr(''))

    if l:counts.total == 0
      return ' OK '
    endif

    let l:errors = l:counts.error
    let l:warnings = l:counts.total - l:errors

    if l:errors > 0
      return '%#BE_StatuslineRedCentre# '.l:errors.' ERR '
    endif

    if l:warnings > 0
      return '%#BE_StatuslineYellow# '.l:warnings.' WARN '
    endif
endfunction

function! BE_ActiveStatusline()
  let l:mode_name   = g:be_modes[mode()]['name']
  let l:mode_colour = g:be_modes[mode()]['highlight']

  let l:stl  = '%#'.l:mode_colour.'#'
  let l:stl .= ' '.l:mode_name.'%{&paste ? "\ [PASTE]" : ""}%{&spell ? "\ [SPELL]" : ""} '
  let l:stl .= '%#'.l:mode_colour.'Centre#'
  " flags => m: modified, r: readonly, h: help, p: preview, y: filetype
  let l:stl .= ' %<%f %m%r %='
  let l:stl .= BE_LinterStatus()
  let l:stl .= '%#'.l:mode_colour.'#'
  let l:stl .= g:BE_statusline_right
  return l:stl
endfunction

function! BE_InactiveStatusline()
  let l:stl  =  ' %<%f %m%r %='
  let l:stl .= g:BE_statusline_right
  return l:stl
endfunction

augroup BE_StatuslineEvents
    autocmd!

    " quickfix and help also need to have their own autocmd because WinEnter
    " and BufWinEnter are not triggered consistently on first opening it
    autocmd FileType  help      setlocal statusline=%!BE_HelpStatusline()
    autocmd FileType  qf        call BE_ListsStatuslineInitial()
    autocmd FileType  nerdtree  setlocal statusline=\ NERDTree
    autocmd FileType  netrw     setlocal statusline=\ %<%f

    autocmd FileType  fugitive          setlocal statusline=\[git]
    autocmd FileType  fugitiveblame     setlocal statusline=\[git]
    autocmd FileType  godebugstacktrace setlocal statusline=\[debug]
    autocmd FileType  godebugvariables  setlocal statusline=\[debug]
    autocmd FileType  godebugoutput     setlocal statusline=\[debug]

    autocmd WinEnter,BufWinEnter  *         call BE_Statusline(1)
    autocmd WinLeave              *         call BE_Statusline(0)
augroup END

set noshowmode " the mode is already shown in the statusline

" ---------------------------------- "
" --- Reload vimrc automatically --- "
" ---------------------------------- "

" <https://github.com/bryankennedy/vimrc/blob/master/vimrc>
autocmd! bufwritepost $MYVIMRC source $MYVIMRC

" ------------------------------------- "
" --- Load additional configuration --- "
" ------------------------------------- "

" You can put here any further customisations or overrides.

if filereadable(glob("~/.vimrc.local"))
  source ~/.vimrc.local
endif

" ---------------------------------------------------- "
" --- Securely enable .vimrc for current directory --- "
" ---------------------------------------------------- "

set exrc
set secure
